package Programmers;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;

public class Number_84021 {

	static class Puzzle{
		int[][] map;
		int count;
		
		Puzzle(int[][] map, int count){
			this.map = map;
			this.count = count;
		}
	}
	static class Pos{
		int x;
		int y;
		
		Pos(int x, int y){
			this.x = x;
			this.y = y;
		}
	}
	
	static List<Puzzle> mapList = new ArrayList<Puzzle>();
	static List<Puzzle> fragList = new ArrayList<Puzzle>();
	static int result = 0;
	public static void main(String[] args) {
		int[][] game_board = {{1,1,0,0,1,0},{0,0,1,0,1,0},{0,1,1,0,0,1},{1,1,0,1,1,1},{1,0,0,0,1,0},{0,1,1,1,0,0}};
		 int[][] table = {{1,0,0,1,1,0},{1,0,1,0,1,0},{0,1,1,0,1,1},{0,0,1,0,0,0},{1,1,0,1,1,0},{0,1,0,0,0,0}};
		 solution(game_board,table);
	}
		
	  public static int solution(int[][] game_board, int[][] table) {
	        int answer = -1;
	        createFragment(game_board, 0);
	        createFragment(table, 1);
	        
	     if(mapList.size() >= fragList.size()) {
	    	 pick(new ArrayList<Integer>(), fragList.size() , 0);
	     }
	     else
	    	 pick(new ArrayList<Integer>(), mapList.size() , 1);
	       
	        return answer;
	    }
	  
	  
	  
	 static void createFragment(int[][] map, int type) {
		  
		 
		  int n = map.length;
		  int m = map[0].length;
		  Queue<Pos> q = new LinkedList<>();
		  boolean visited[][] = new boolean[n][m];
		  
		  for(int i =0; i<n; i++) {
			  for(int j =0; j<n; j++) {
				  if(map[i][j] == type && !visited[i][j]) {
					  List<Integer> listx = new ArrayList<>();		
					  List<Integer> listy = new ArrayList<>();			  
					 q.add(new Pos(i,j));
					 int cnt = 0;
					 int minX = Integer.MAX_VALUE;
					 int minY = Integer.MAX_VALUE;
					 visited[i][j] = true;
					 while(!q.isEmpty()) {
						 Pos top = q.poll();
						 cnt++;
						
						 int x = top.x;
						 int y = top.y;
						 minX =Math.min(minX, x);
						 minY =Math.min(minY, y);
						 listx.add(x);
						 listy.add(y);
						 
						 //위
						 if(0<=x-1 && !visited[x-1][y]&& map[x-1][y] ==type) {
							 q.add(new Pos(x-1,y));
							 visited[x-1][y] = true;
						 }
						 //아래
						 if(x+1<n && !visited[x+1][y]&& map[x+1][y] ==type) {
							 q.add(new Pos(x+1,y));
							 visited[x+1][y] = true;
						 }
						 //왼쪽
						 if(0<=y-1 && !visited[x][y-1]&& map[x][y-1] ==type) {
							 q.add(new Pos(x,y-1));
							 visited[x][y-1] = true;
						 }
						 //오른쪽
						 if(y+1 <m && !visited[x][y+1]&& map[x][y+1] ==type) {
							 q.add(new Pos(x,y+1));
							 visited[x][y+1] = true;
						 }						 
					 }
					 
					 Set<Integer> set = new HashSet<Integer>(listx);
					 int length1 = set.size();
					 set = new HashSet<Integer>(listy);
					 int length2 = set.size();
					 
					 int length3 = Math.max(length1, length2);
					 int[][] frag = new int[length3][length3];
					 
					 for(int k =0; k<cnt; k++) {
						 frag[listx.get(k)-minX][listy.get(k)-minY] = 1;
					 }
					 
					 if(type ==0) {
						 mapList.add(new Puzzle(frag, cnt));
					 }
					 else if(type ==1) {
						 fragList.add(new Puzzle(frag, cnt));
					 }
				  }
			  }
		  }		 
	  }
	
	 static void pick(List<Integer> list, int cnt, int type ) {
		  
		  if(list.size() == cnt) {
			  check(list,cnt,type);
			  return;
		  }

		  for(int i = 0; i<cnt; i++) {
			  if(!list.contains(Integer.valueOf(i))) {
				  list.add(i);
				  pick(list,cnt,type); 
				  list.remove(list.size()-1);
			  }
		  }
	  }
	  
	  	  static void check(List<Integer> order, int cnt, int type) {
		  
		  for(int i =0; i<cnt; i++) {
			  if(type ==0) {
				  rotateCheck(mapList.get(order.get(i)), fragList.get(i));
			  }
			  else if( type==1) {
				  rotateCheck(mapList.get(i), fragList.get(order.get(i)));
			  }
		  }
	  }

	static void rotateCheck(Puzzle puzzle1, Puzzle puzzle2) {
		if(puzzle1.count != puzzle2.count || puzzle1.map.length != puzzle2.map.length)			
			return;
		
		int map1[][] = puzzle1.map;
		int map2[][] = puzzle2.map;
		int n = map1.length;
		
		Loop1 :
		for(int k=0; k<3; k++) {
		
		for(int i =0; i<n; i++) {
			for(int j =0; j<n; j++) {
				if(map1[i][j] != map2[i][j]) {
					map2 = rotateMap(map2);
					continue Loop1;
				}
			}
		}
			result+=puzzle1.count;
			return;
		}
	}
	static int[][] rotateMap(int[][] map2) {
		int n = map2.length;
		int [][] newMap = new int[n][n];
		
		for(int i =0; i<n; i++) {
			for(int j =0; j<n; j++) {
				newMap[i][j] = map2[n-1-j][i];
			}
		}
		return newMap;
	}
  
}
